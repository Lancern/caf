#include "Infrastructure/Trie.h"
#include "Basic/Identity.h"
#include "Basic/Type.h"
#include "Basic/CallbackFunctionManager.h"
#include "Basic/Function.h"

#include <unordered_map>

namespace caf {

/**
 * @brief Provide a range of type IDs in a function signature.
 *
 */
class FunctionSignatureTypeRange {
public:
  /**
   * @brief Iterator of function signature type ID range. This iterator produces type IDs in a
   * function signature, beginning with the return type, then the first argument, the second
   * argument, etc.
   *
   */
  class FunctionSignatureTypeIterator {
  public:
    using value_type = uint64_t;

    bool operator==(const FunctionSignatureTypeIterator& another) const {
      return _signature == another._signature && _index == another._index;
    }

    bool operator!=(const FunctionSignatureTypeIterator& another) const {
      return _signature != another._signature || _index != another._index;
    }

    value_type operator*() const {
      if (_index == -1) {
        return _signature->returnType()->id();
      }

      return _signature->args()[_index]->id();
    }

    FunctionSignatureTypeIterator& operator++() {
      ++_index;
      return *this;
    }

    friend class FunctionSignatureTypeRange;

  private:
    const FunctionSignature* _signature;
    int _index;

    explicit FunctionSignatureTypeIterator(const FunctionSignature* signature, int index)
      : _signature(signature),
        _index(index)
    { }
  }; // class FunctionSignatureTypeIterator

  using IteratorType = FunctionSignatureTypeIterator;

  explicit FunctionSignatureTypeRange(const FunctionSignature& signature)
    : _signature(signature),
      _begin { &signature, -1 },
      _end { &signature, static_cast<int>(signature.args().size()) }
  { }

  IteratorType begin() const { return _begin; }

  IteratorType end() const { return _end; }

private:
  const FunctionSignature& _signature;
  IteratorType _begin;
  IteratorType _end;
}; // class FunctionSignatureTypeRange

/**
 * @brief Implement grouping of function signatures. Grouping is done via a trie.
 *
 */
class CallbackFunctionManager::FunctionSignatureSet {
public:
  /**
   * @brief Add the given signature to this @see CallbackFunctionManager object and returns the ID
   * of the signature. The same function signature will get the same signature ID.
   *
   * @param signature the function signature.
   * @return int the ID of the function signature.
   */
  int Insert(const FunctionSignature& signature) {
    FunctionSignatureTypeRange typeIdRange { signature };
    auto signatureId = _signatureIdAlloc.next();
    _trie.Insert(typeIdRange.begin(), typeIdRange.end(), signatureId);

    return signatureId;
  }

private:
  // The following trie maintains mapping from function signature to function signature group IDs.
  // The signature ID is generated by the corresponding ID allocator field.
  Trie<uint64_t, int> _trie;
  IncrementIdAllocator<int> _signatureIdAlloc;
}; // class CallbackFunctionManager::FunctionSignatureSet

CallbackFunctionIdentifier CallbackFunctionManager::Insert(const FunctionSignature& signature) {
  auto signatureId = _signatures->Insert(signature);
  auto i = _slots.find(signatureId);
  if (i == _slots.end()) {
    i = _slots.insert(std::make_pair(signatureId, std::vector<int> { })).first;
  }
  auto funcId = _funcIdAlloc.next();
  i->second.push_back(funcId);

  CallbackFunctionIdentifier ret;
  ret.FunctionId = funcId;
  ret.SignatureId = signatureId;
  return ret;
}

} // namespace caf
